# goit-algo-hw-09
Жадібні алгоритми та динамічне програмування

**ПОРІВНЯННЯ ШВИДКОСТЕЙ ЖАДІБНОГО АЛГОРИТМУ ТА АЛГОРИТМУ ДИНАМІЧНОГО ПРОГРАМУВАННЯ (ДП)**

В таблиці представлені значення швидкостей алгоритмів жадібного та динамічного програмування (ДП) для пошуку у масивах з випадково згенерованих чисел з довжиною масивів 10, 100, 1000, 10000 відповідно.


|        |     10   |   100    |   1000   |  10000   |
|--------|----------|----------|----------|----------|
|Greedy  |0.00000202|0.00001249|0.00010372|0.00142506|
|Dynamic |0.00020274|0.00087600|0.00568873|0.05161987|
|Різниця | 100      | 70       |55        |36        |


Як видно з таблиці, швидкість алгоритму ДП представлена більшими значеннями (тобто цей алгоритм повільніший) за значення швдкості жадібного алгоритму. З урахуванням цьго, різницеєю в даному випадку є швидкість ДП поділена на швидкість жадібного алгоритму. ДП в середньому в 50-70 разів повільніший за жадібний алгоритм. На вибірках різної кількості спостерігаємо, що жадібний алгоритм в 14-100% швидший за ДП в залежності від розміру вибірки.


**ПОРІВНЯННЯ ТОЧНОСТІ АЛГОРИТМІВ**

Незважаючи на те, що жадібний алгоритм показує кращі результати по швидкості, він є менш оптимальним з точки зору розподілу ресурсів.

Нижче наведені дані показують, що чим більша щільність значень (велика кількість значень при малому діапазоні), тим менш помітна різниця між ДП та жадібним. 

Цільові значення, які потрібно "зібрати" за допомогою алгоритмів:

113, 264, 551, 689, 1250, 2460, 7867.

Перше значення в дужках (нижче) - різниця між цільовим значенням і значенням, отриманим із сукупності (списку) зміних за допомогою алгоритмів. 

Друге значення - кількість елементів, з яких алгоритм "зібрав" цільове значення.

Наприклад, для діапазону "від 1 до 100, кількість 1000": 0 означає, що цільове значення було повністю досягнуто; 2 означає, що алгоритм використав 2 елемента вхідного списку, щоб зібрати число 113.

Для діапазону "від 1 до 1000, кількість 100", де кількість та щільність значень менша, тобто більша відстань між значеннями, цільове значення з використанням жадібного алгоритму досягається не повністю. Так, різниця 2 показує, що замість очікуваних 113 алгоритм повернув 111 одиниць. Для тієї ж вибірки алгоритм ДП використав більше елементів (3 порівняно з 1 елементом, використаним жадібним алгоритмом), проте результат дорівнював цільовому значенню.

Діапазон від 1 до 100, кількість 1000:
'gr': [(0, 2), (0, 3), (0, 6), (0, 7), (0, 13), (0, 25), (0, 79)], 
'dp': [(0, 2), (0, 3), (0, 6), (0, 7), (0, 13), (0, 25), (0, 79)]

Діапазон від 1 до 1000, кількість 10000:
'gr': [(0, 1), (0, 1), (0, 1), (0, 1), (0, 2), (0, 3), (0, 8)], 
'dp': [(0, 1), (0, 1), (0, 1), (0, 1), (0, 2), (0, 3), (0, 8)]

Діапазон від 1 до 50, кількість 10:
'gr': [(0, 4), (0, 6), (0, 13), (0, 17), (0, 35), (0, 82), (0, 158)], 
'dp': [(0, 4), (0, 6), (0, 13), (0, 17), (0, 28), (0, 82), (0, 158)]


Діапазон від 1 до 1000, кількість 100:
'gr': [(2, 1), (1, 2), (4, 1), (0, 2), (3, 4), (20, 3), (8, 8)], 
'dp': [(0, 3), (0, 2), (0, 2), (0, 2), (0, 2), (0, 3), (0, 9)]

Діапазон від 1 до 100, кількість 10:
'gr': [(1, 2), (6, 3), (0, 17), (0, 9), (5, 15), (0, 30), (7, 79)], 
'dp': [(0, 3), (0, 4), (0, 7), (0, 9), (0, 16), (0, 28), (0, 80)]

Діапазон від 1 до 20, кількість 6:
'gr': [(1, 7), (1, 18), (4, 28), (0, 44), (0, 63), (1, 118), (0, 376)], 
'dp': [(0, 10), (0, 17), (0, 28), (0, 44), (0, 63), (0, 118), (0, 375)]

Діапазон від 1 до 10000, кількість 1000:
'gr': [(7, 1), (2, 1), (7, 1), (5, 1), (0, 2), (3, 1), (9, 1)], 
'dp': [(113, 0), (0, 2), (0, 2), (0, 2), (0, 2), (0, 2), (0, 2)]

Отже, можна зробити висновок, що, чим більші кількість значень та їх різноманіття, тем менше відрізняються результати роботи алгоритмів. І якщо нам потрібна швидкість і певна похибка не буде критичною, можна використовувати жадібний алгоритм.
З іншого боку, якщо точність отриманого результату є вирішальною для певного типу задач, доречніше використовувати алгоритм динамічного програмування.
